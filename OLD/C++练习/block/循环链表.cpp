#include <algorithm>
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
using namespace std;
struct Node{
    int val;
    Node*next;
};
int main(){
    int n;
    cin>>n;
    Node a[n];
    for(int i = 0; i < n-1; i++){
        a[i].val=i+1;
        a[i].next = &a[i+1];
    }
    a[n-1].val = n;
    a[n-1].next = &a[0];
    Node* p=&a[0];
    while(p->next!=p){
        p->next->next=p->next->next->next;
        p = p->next->next;
    }
    cout << p->val<<endl;
}
/*
   算法训练  筛选号码
时间限制：1.0s     内存限制：512.0MB

问题描述
　　有n个人围成一圈，顺序排号（编号为1到n）。从第1个人开始报数(从1到3报数)，凡报到3的人退出圈子。从下一个人开始继续报数，直到剩下最后一个人，游戏结束。
　　问最后留下的是原来第几号的那位。
　　举个例子，8个人围成一圈：
　　1  2  3  4  5  6  7  8
　　第1次报数之后，3退出，剩下：
　　1  2  4  5  6  7  8  （现在从4开始报数）
　　第2次报数之后，6退出，剩下：
　　1  2  4  5  7  8  （现在从7开始报数）
　　第3次报数之后，1退出，剩下：
　　2  4  5  7  8  （现在从2开始报数）
　　第4次报数之后，5退出，剩下：
　　2  4  7  8  （现在从7开始报数）
　　第5次报数之后，2退出，剩下：
　　4  7  8  （现在从4开始报数）
　　第6次报数之后，8退出，剩下：
　　4  7  （现在从4开始报数）
　　最后一次报数之后，4退出，剩下：
　　7.
　　所以，最后留下来的人编号是7。
输入格式
　　一个正整数n，(1< n< 10000)
输出格式
　　一个正整数，最后留下来的那个人的编号。
样例输入
8
样例输出
7
数据规模和约定
　　对于100%的数据，1< n< 10000。

*/
